<html>
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  .vertGrid .domain {
    display: none;
  }

  .vertGrid line {
    stroke: "black";
    stroke-width: 2;
  }

  .horzGrid .domain {
    display: none;
  }

  .horzGrid line {
    stroke: "black";
    stroke-width: 2;
  }

  .tick text {
    font-weight: bold;
    font-size: 16px;
  }

  body {
    background-color: rgb(167, 213, 236);
    height: 100vh;
    /* Ensure full height */
    margin: 0;
    /* Remove default margin */
  }

  .container {
    display: flex;
    width: 100%;
    height: 100%;
  }

  .half {
    flex: 1;
  }

  .half h1 {
    text-align: center;
  }

  .half h2 {
    text-align: center;
  }

  .half h3 {
    text-align: center;
  }

  .game {
    flex: 1;
  }

  .p1 {
    background-color: black;
    color: white;
    border-width: 2px;
    border-color: white;
    border-style: solid;
    height: 70px;
    width: 170px;
    font-size: 22px;
    margin-right: 25px;
  }

  .p1:hover {
    background-color: rgba(0, 0, 0, .5);

  }

  .p2:hover {
    background-color: rgba(187, 187, 187, 0.5);
  }

  .reset:hover {
    background-color: rgba(187, 187, 187, 0.5);
  }

  button:hover {
    cursor: pointer;
  }

  .p2 {
    background-color: white;
    color: black;
    border-width: 2px;
    border-color: black;
    border-style: solid;
    height: 70px;
    width: 170px;
    font-size: 22px;
    margin-left: 25px;
    margin-right: 25px;
  }

  .p3 {
    background-color: rgb(222, 143, 143);
    color: rgb(85, 23, 23);
    border-width: 2px;
    border-color: rgb(85, 23, 23);
    border-style: solid;
    height: 70px;
    width: 170px;
    font-size: 22px;
    margin-left: 25px;
  }

  .p3:hover {
    background-color: rgba(222, 143, 143, 0.6);
  }

  .reset {
    background-color: white;
    color: black;
    border-width: 2px;
    border-color: black;
    border-style: solid;
    height: 70px;
    width: 170px;
    font-size: 22px;
    margin-left: 25px;
  }

  .instructions {
    text-align: left;
    font-size: 22px;
    margin-right: 20px;
    margin-left: 20px;
    line-height: 1.5;
  }

  .buttons {
    display: flex;
    justify-content: center;
  }

  #win {
    display: none;
    justify-content: center;
  }

  #win-text {
    font-size: 60px;
    margin: 35px;
  }

  #reset {
    display: none;
    justify-content: center;
  }

  #player-id {
    display: none;
    justify-content: center;
    height: fit-content;
  }

  #player-text {
    font-size: 45px;
    margin: 0;
  }

  .eyes {
    display: none;
  }
</style>

<body>
  <div class="container">
    <div class="half">
      <h1>Welcome to TD-Gomoku!</h1>
      <h3>By Paul Garell and Lauren Cali</h3>
      <br>
      <h2>How to Play</h2>
      <div class="instructions">
        <p> The black stone plays first. Players alternate turns placing their pieces in a strategic manner at grid
          intersections. To win the game, a player must successfully get at least five of their pieces in a row unbroken
          vertically, horizontally, or diagonally. If the board fills and no player has achieved five consecutive
          pieces, the game ends in a draw.
        </p>

        <p>To begin, select whether you would like to be Player 1 or Player 2. </p>
        <p>Or, sit back and watch the bot play itself!</p>
        <p>When it's your turn, click on the intersection where you would like to place your piece. You must wait for
          the algorithm
          to make its move before you take your next turn.</p>
      </div>
      <div class="buttons" id="buttons">
        <button type="button" class="p1" id="p1" onclick="start(1)">Player 1</button>
        <button type="button" class="p2" id="p2" onclick="start(2)">Player 2</button>
        <button type="button" class="p3" id="p3" onclick="start(3)">Watch Bot Play Itself</button>
      </div>
      <div class="player-id" id="player-id">
        <p class="player-text" id="player-text"></p>
        <img class="eyes" id="eyes" src="eyeballs.png" alt="eyeballs">
      </div>
      <div id="win">
        <p id="win-text"></p>
      </div>
      <div id="reset">
        <button type="button" class="reset" onclick="reset()">Play Again</button>
      </div>
      <!-- <input type="text" id="testInput">
      <button type="button" onclick="submit()">Submit</button> -->
    </div>
    <div class="game">
      <svg height="850" width="850" id="board"></svg>
    </div>
  </div>
  <script>
    var piece = 1;
    var displayWin = false;
    var turnCount = 0;

    var pieceMatrix = [];
    let rows = 15;
    let cols = 15;

    for (var i = 0; i < rows; i++) {
      var row = [];

      for (var j = 0; j < cols; j++) {
        row.push(0); // No pieces at start
      }
      pieceMatrix.push(row);
    }

    //START OF BOARD SET-UP

    //Used as svg margin
    const margin = { "top": 20, "bottom": 20, "left": 20, "right": 20 };
    //Used as margin for board border
    const bmargin = { "top": 30, "bottom": 30, "left": 30, "right": 30 };

    const svg = d3.select("svg#board");
    const height = svg.attr("height");
    const width = svg.attr("width");
    const boardWidth = width - margin.left - margin.right;
    const boardHeight = height - margin.top - margin.bottom;

    let base = svg.append("rect")
      .attr("class", "base")
      .attr("fill", "#ba8857")
      .attr("x", margin.left)
      .attr("y", margin.top)
      .attr("width", boardWidth)
      .attr("height", boardHeight);


    //VERTICAL GRIDLINES (Bottom Axis)
    const gridVScale = d3.scaleLinear()
      .domain([0, 14])
      .range([margin.top + bmargin.top, height - margin.bottom - bmargin.bottom]);

    let vertGridlines = d3.axisBottom(gridVScale)
      .tickSize(boardHeight - bmargin.top - bmargin.bottom)
      .tickFormat("");

    var tickLabels = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"];

    //Makes axis labels
    let bottomAxis = d3.axisBottom(gridVScale)
      .tickSize(0)
      .tickFormat(d => { return tickLabels[d] });

    svg.append("g")
      .attr("class", "vertGrid")
      .attr("transform", `translate(0,${margin.top + bmargin.top})`)
      .call(bottomAxis)
      .selectAll(".tick text")
      .attr("transform", `translate(0,${boardHeight - bmargin.top - bmargin.bottom + 30})`);

    svg.append("g")
      .attr("class", "vertGrid")
      .attr("transform", `translate(0,${margin.top + bmargin.top})`)
      .call(vertGridlines);

    //HORIZONTAL GRIDLINES (Left Axis)
    const gridHScale = d3.scaleLinear()
      .domain([0, 14])
      .range([height - margin.bottom - bmargin.bottom, margin.top + bmargin.top]);

    let horzGridlines = d3.axisRight(gridHScale)
      .tickSize(boardWidth - bmargin.left - bmargin.right)
      .tickFormat("");

    //Makes axis labels
    let leftAxis = d3.axisLeft(gridHScale)
      .tickSize(0);


    svg.append("g")
      .attr("class", "horzGrid")
      .attr("transform", `translate(${margin.left + bmargin.left},0)`)
      .call(leftAxis)
      .selectAll(".tick text")
      .attr("transform", `translate(-30,0)`);


    svg.append("g")
      .attr("class", "horzGrid")
      .attr("transform", `translate(${margin.left + bmargin.left},0)`)
      .call(horzGridlines);


    //Circle Positioning Scales
    const circleScaleX = d3.scaleLinear()
      .domain([0, 14])
      .range([margin.left + bmargin.left, width - margin.right - bmargin.right]);

    const circleScaleY = d3.scaleLinear()
      .domain([0, 14])
      .range([height - bmargin.bottom - margin.bottom, bmargin.top + margin.top])


    //Radius of game pieces. Based on width of columns
    const circleRad = ((boardWidth - bmargin.left - bmargin.right) / 14) / 2.2;

    for (let i = 0; i < 15; i++) {
      for (let j = 0; j < 15; j++) {
        svg.append("circle")
          .attr("class", "r" + String(j) + "c" + String(i)) //Classified based on their row and column (grid location)
          .attr("r", circleRad)
          .attr("fill", "black")
          .attr("opacity", 0)
          .attr("cx", circleScaleX(i))
          .attr("cy", circleScaleY(j))
          .on("click", appearFunc);
      }
    }

    //END OF BOARD SET-UP

    //START OF GAME PLAY FUNCTIONALITY

    //Cannot begin play until you pick p1 or p2
    var allowClick = false;

    //Begins play once user selects if they want to be P1 or P2
    function start(player) {
      console.log("clicked");
      let p = document.getElementById('buttons');

      p.style.display = 'none';
      let dis = document.getElementById('player-id');
      let disText = document.getElementById('player-text');

      dis.style.display = "flex";

      if (player == 1) {
        allowClick = true;
        disText.textContent = "You are Player 1.";
      }
      else if (player == 2) {
        disText.textContent = "You are Player 2.";
        computerPlays();
      }
      else {
        let eyes = document.getElementById('eyes');
        eyes.style.display = 'flex';
        disText.textContent = "You are watching the bot.";
        console.log("TBD");
      }
    }

    function appearFunc(event, d) {
      if (allowClick) {
        turnCount += 1;
        let color = "";
        if (piece == 1) {
          color = "black";
        }
        else {
          color = "white";
        }
        d3.select(this)
          .attr("fill", color)
          .attr("opacity", 1)
          .on("click", null); //removes listener so cant be clicked again for duration of game
        let tag = d3.select(this).attr("class");
        updateMatrix(piece, tag);
        if (piece == 1) {
          piece = 2;
        }
        else { piece = 1; }//so next placed piece has opposite color
        allowClick = false;
        let coor = parseLocation(tag);

        if (winCheck(coor[0], coor[1])) {
          console.log("game over");
        }
        else {
          computerPlays();
        }
      }
      else {
        console.log("It's not your turn.")
      }
    }

    //Updates the matrix to take into account where pieces are
    function updateMatrix(color, tag) {
      console.log(pieceMatrix);
      let loc = parseLocation(tag); //Parses a circle's class to obtain its grid location in the format [row,col]
      pieceMatrix[loc[0]][loc[1]] = color;
    }

    //Parses a circles class which is a string in format r(row#)c(col#)
    function parseLocation(tag) {
      var regex = /r(\d+)c(\d+)/;

      // Use exec() to extract the matched numbers
      var match = regex.exec(tag);

      if (match) {
        //Should always match since classes are generated at set-up and cannot be changed
        // Extracted numbers are in match[1] and match[2]
        let i = match[1];
        let j = match[2];
        let loc = [parseInt(i), parseInt(j)];
        return loc;
      }

    }

    async function computerPlays() {
      try {
        let test_data = { "board": JSON.stringify(pieceMatrix), "player": piece };
        let move = "";
        await fetch("http://localhost:8000/receive_state", {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(test_data)
        })
          .then(response => response.json())
          .then(data => move = data)  //API responds with JSON containing algorithm's move in format {"move":"row-col"}
          .catch(error => console.error('Error:', error));

        //console.log(move);
        turnCount += 1;
        inputValue = move["move"].split("-");

        let color = "";
        if (piece == 1) {
          color = "black";
        }
        else {
          color = "white";
        }

        let circleClass = "r" + inputValue[0] + "c" + inputValue[1];  //convert move to corresponding circle class

        d3.select("circle." + circleClass)
          .attr("fill", color)
          .attr("opacity", 1)
          .on("click", null); //removes listener so cant be clicked again

        updateMatrix(piece, circleClass);

        if (winCheck(parseInt(inputValue[0]), parseInt(inputValue[1]))) {
          console.log("game over");
        }

        else {

          if (piece == 1) {
            piece = 2;
          }
          else {
            piece = 1;
          } //so next placed piece has opposite color
          allowClick = true; //lets user place their piece again
        }

      }

      catch (error) {
        console.log('Error: ' + error);
      }

    }

    // function submit() {
    //   //console.log("test");
    //   //This function controls the input box that I am using to simulate algorithm game play
    //   //To be removed once code is interfaced with actual algorithm
    //   var inputValue = document.getElementById("testInput").value;

    //   let color = "";
    //   if (piece < 0) {
    //     color = "black";
    //   }
    //   else {
    //     color = "white";
    //   }

    //   inputValue = inputValue.split("-")


    //   let circleClass = "r" + inputValue[0] + "c" + inputValue[1];

    //   d3.select("circle." + circleClass)
    //     .attr("fill", color)
    //     .attr("opacity", 1)
    //     .on("click", null); //removes listener so cant be clicked again

    //   updateMatrix(piece, circleClass);
    //   piece *= -1; //so next placed piece has opposite color
    //   allowClick = true; //lets user place their piece again
    // }

    //END OF GAMEPLAY FUNCTIONALITY

    //START WIN CHECKS


    function checkDiagF(row, col) {
      let ri = row + 1;
      let rj = col + 1;
      count = 1;

      while (ri < pieceMatrix.length && rj < pieceMatrix.length && pieceMatrix[ri][rj] == pieceMatrix[row][col]) {
        ri += 1;
        rj += 1;
        count += 1;
        if (count >= 5) {
          return true;
        }

      }

      let li = row - 1;
      let lj = col - 1;

      while (li >= 0 && lj >= 0 && pieceMatrix[li][lj] == pieceMatrix[row][col]) {
        li -= 1;
        lj -= 1;
        count += 1;
        if (count >= 5) {
          //console.log("win");
          return true;
        }
      }
      return false;

    }

    function checkDiagB(row, col) {
      let li = row + 1;
      let lj = col - 1;
      let count = 1;

      while (li < pieceMatrix.length && lj >= 0 && pieceMatrix[li][lj] == pieceMatrix[row][col]) {
        li += 1;
        lj -= 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }

      let ri = row - 1;
      let rj = col + 1;

      while (ri >= 0 && rj < pieceMatrix.length && pieceMatrix[ri][rj] == pieceMatrix[row][col]) {
        ri -= 1;
        rj += 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }

      return false;
    }


    function checkV(row, col) {
      let ui = row + 1;
      let count = 1;

      while (ui < pieceMatrix.length && pieceMatrix[ui][col] == pieceMatrix[row][col]) {
        ui += 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }

      let di = row - 1;
      while (di >= 0 && pieceMatrix[di][col] == pieceMatrix[row][col]) {
        di -= 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }
      return false;
    }

    function checkH(row, col) {

      let ri = col + 1;
      count = 1;

      while (ri < pieceMatrix.length && pieceMatrix[row][ri] == pieceMatrix[row][col]) {
        ri += 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }

      let li = col - 1;
      while (li >= 0 && pieceMatrix[row][li] == pieceMatrix[row][col]) {
        li -= 1;
        count += 1;
        if (count >= 5) {
          return true;
        }
      }
      return false;
    }


    function winCheck(row, col) {
      let res = checkDiagF(row, col);
      let res1 = checkDiagB(row, col);
      let res2 = checkV(row, col);
      let res3 = checkH(row, col);
      let winDiv = document.getElementById('win');
      let resetDiv = document.getElementById('reset');
      let winText = document.getElementById('win-text');
      if (res || res1 || res2 || res3) {
        console.log("WIN");
        displayWin = true;
        winDiv.style.display = 'flex';
        resetDiv.style.display = 'flex';
        let message = "wins!";
        if (pieceMatrix[row][col] == -1) {
          message = "Player 1 " + message;
        }
        else {
          message = "Player 2 " + message;
        }
        winText.textContent = message;
        return true;
      }

      //If no one has won the game, but 225 pieces have been placed, 
      //there is a draw since the board is now full
      else if (turnCount == 225) {
        displayWin = true;
        winDiv.style.display = 'flex';
        resetDiv.style.display = 'flex';
        winText.textContent = "It's a draw!";
      }
      return false;
    }


    //END WIN CHECKS

    //Reset game to play again
    function reset() {
      displayWin = false; //don't currently use this variable
      turnCount = 0;

      //Clear all elements related to displaying a win
      let winDiv = document.getElementById('win');
      let resetDiv = document.getElementById('reset');
      let winText = document.getElementById('win-text');
      let p = document.getElementById('buttons');
      let dis = document.getElementById('player-id');

      winDiv.style.display = 'none';
      resetDiv.style.display = 'none';
      p.style.display = 'flex';
      dis.style.display = 'none';

      //Reset to starting color (black)
      piece = -1;

      let rows = 15;
      let cols = 15;
      //Clear piece matrix (no pieces on board)
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < cols; j++) {
          pieceMatrix[i][j] = 0;
        }
      }

      //Reset circle elements so they disappear and can be clicked again
      let circle = d3.selectAll("circle")
        .attr("fill", "black")
        .attr("opacity", 0)
        .on("click", appearFunc);

    }


  </script>
</body>

</html>